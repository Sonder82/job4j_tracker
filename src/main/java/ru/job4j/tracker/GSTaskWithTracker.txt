Перед началом работы в настройках указал что будет GC Serial,
памяти в heap выделил 124mb.
Анализ приложения начал с запуска утилиты jmap.
Запустил приложение, и добавлял в хранилище по 200000 объектов Item.
В jmap при добавлении объектов это хорошо было видно по появлению
таких объектов как Item, LocalDate, LocalDateTime.
Все это просматривается через гистаграмму -histo.
Примерно к 400000 добавленных объектов GC справлялся очисткой в
young области. Заполнение памяти смотрел через -heap.
Дальнейшее прибавление объектов приводило уже к тому, что GC
включал полную сборку Full. Это хорошо замечалось в консоли IDEA, как
замедленным добавлением заявок, это прямо хорошо было видно.
При очередном добавлении 200000 заявок, при добавлении 794000 заявки
приложении остановилось с out of memory.

Следом продолжил работать с утилитой jstat.
Настройки и алгоритм работы с приложением остался тем же.
Поведение приложения было соответственно тем же.
При работе с jstat выделил для себя удобство в том,
что можно посмотреть что происходит с областями памяти,
как они заполняются, как данные переходят из одной области в другую,
как очищаются. Размер областей задается в kb.

Следом продолжил работать с утилитой jconsole.
Настройки и алгоритм работы с приложением остался тем же.
При работе с jconsole выделил для себя возможность работать
в графическом интерфейсе. Посмотреть на графике как изменяются области
памяти,загрузку процессора.
В целом jconsole схожа с visualVM, что была в задании
1. Эксперименты с различными GC.
